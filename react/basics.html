<div class="flex-container">
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>React JS</span>
<code class="searchcode language-js">
React is a JavaScript library for building user interfaces. 
React uses virtual DOM to render the view.
Each time the data changes, a new virtual DOM gets created.
SEO friendly
Reusable components
JSX - It allows us to write HTML inside JavaScript and place 
them in the DOM without using functions like createElement( )
Install - npx create-react-app myfirstreact | 
cd myfirstreact | npm start

Lifecycle of Components
Each component in React has a lifecycle which you can 
monitor and manipulate during its three main phases.
The three phases are: Mounting, Updating, and Unmounting.

Mounting - means putting elements into the DOM.
constructor()
getDerivedStateFromProps()
render()
componentDidMount()

Updateing
A component is updated whenever there is a change in the 
component's state or props.
render()
componentDidUpdate()
shouldComponentUpdate()

Unmounting - next phase in the lifecycle is when a component 
is removed from the DOM
componentWillUnmount()
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>Dynamic Value - inside a template</span>
<code class="searchcode language-js">
Components are like functions that return HTML elements.
Classes are a template for creating objects. They encapsulate data with code to work on that data.
import React from 'react';
import ReactDOM from 'react-dom'; --> ReactDOM is a package that provides DOM specific methods , managing DOM elements(render())
class hello extends React.PureComponent { -> doesn't re-renders when state/props as been updated with same values. shouldComponentUp
  constructor(props) { -> props are like function arguments, and you send them into the component as attributes.
    super(props); -> super by calling this it has access to the constructor
    this.state = {-> state components has a built-in state object. state object changes, the component re-renders.
      kAcctLimit: 0,};
      this.shoot =this.shoot.bind(this);  -> bind binds this function with constructor properties using this keyword.
    }
  shoot = () => {}
  componentDidMount(){} - ->is a hook that gets invoked right after a React component has been first render().
  render() { --> view to be rendered to the browser window.
    const { kAcctDetails} = this.props;
    const mystyle = {color: "white"};
return (
&lt;div style={mystyle}&gt;
  &lt;button onClick={this.shoot} style={{color: "red" }}&gt;Take the Shot!&lt;/button&gt;
  &lt;div msg.length&gt; 0 && !isLogin ? &lt;h2&gt; {msg.length}&lt;/h2&gt; : &lt;h2&gt;no messages.&lt;/h2&gt;
  &lt;/div&gt;
&lt;/div&gt;)
}}
export default hello; --> expose the component to other modules.
ReactDOM.render(
&lt;hello /&gt;, document.getElementById('my'))
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>React</span>
<code class="searchcode language-js">
callback function as an argument of setState()
Since setState() is asynchronous the callback function is used for any post action.

React.createElement()- const title = React.createElement('h1', {}, 'My First React Code');

higher-order component (HOC) is a function that takes a component and returns a new component. 
const EnhancedComponent = higherOrderComponent(WrappedComponent)

Reconciliation - When a component's props or state change, 
React decides whether an actual DOM update is necessary by
comparing the newly returned element with the previously rendered one. 
When they are not equal, React will update the
DOM. This process is called reconciliation.

Synthetic events combine the response of different browser's native events 
into one API, ensuring that the events are
consistent across different browsers.
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>Axios get and post</span>
<code class="searchcode language-js">
componentDidMount() { 
  axios.get(`https://jsonplaceholder.typicode.com/users`)
  .then(res => {
  const persons = res.data;
  this.setState({ persons });
}) }
const user = { name: this.state.name}; 
  axios.post(`https://jsonplaceholder.typicode.com/users`, 
  { user }) 
  .then(res => {
  console.log(res);
  console.log(res.data);
})
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>Dynamic Value - inside a template</span>
<code class="searchcode language-js">
function App() {
const title = "New title"
return ( 
&lt;div&gt;
 &lt;h1&gt;{ title } &lt;/h1&gt;
 &lt;h1&gt;Hello World &lt;/h1&gt;
 &lt;h1&gt; [1,2,3,4,5]  &lt;/h1&gt;
 &lt;h1&gt;{ Math.random() * 10 } &lt;/h1&gt;
 &lt;/div&gt;)}
export default App;
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>getDerivedStateFromProps</span>
<code class="searchcode language-js">
It enables a component to update its internal state
as the result of changes in props.

state = {
  cachedSomeProp: null
  // ... rest of initial state
};
static getDerivedStateFromProps(nextProps, prevState) {
  // do things with nextProps.someProp and prevState.cachedSomeProp
  return {
  cachedSomeProp: nextProps.someProp,
  // ... other derived state properties
};}
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>Stateless Functional Component</span>
<code class="searchcode language-js">
Functional components are basic JavaScript functions. 
These are typically arrow functions 
but can also be created with
the regular function keyword.
Sometimes referred to as “dumb” or “stateless” components 
as they simply accept data and display them in some form; that
is they are mainly responsible for rendering UI.

import React from 'react'
const App = () => {
    return (
    )}
export default App
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>Event Handlers</span>
<code class="searchcode language-js">
function app() {
  handleClick = () => {
    console.log("object");
  };
  return (
    &lt;div&gt;
      &lt;button onClick={handleClick}&gt;&lt;/button&gt;
      &lt;button onClick={() => handleClick('parameter', e)}&gt;
      &lt;/button&gt;
    &lt;/div&gt;
  );}
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>Lists</span>
<code class="searchcode language-js">
render() {
const data =[{"name":"test1"},{"name":"test2"}];
const listItems = data.map((d) =>
&lt;li key={d.name}&gt;{d.name}&lt;/li&gt;
);
return ( &lt;div&gt; {listItems } &lt;/div&gt; ); }
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>Props - pass data from parent to child</span>
<code class="searchcode language-js">
    handleClick = () => console.log()
&lt;blogs data={blogsdata} title={'All blogs'} 
handleclick={handleClick}/&gt;

function Blogs = ({data, title, handleclick}) => {
    return (
        &lt;div&gt;
            &lt;p&gt;{title}&lt;/p&gt;
            &lt;p&gt;{data}&lt;/p&gt;
            &lt;button onClick={handleclick('1')}/&gt;
        &lt;/div&gt;
    )
}
export default Blogs


</code>
</pre>
  </div>

  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>Conditional Templates</span>
<code class="searchcode language-js">
//Runs only when first condition is true
{Blogs && &lt;Blogs data={data}&gt;}
{isPending ? &lt;p&gt;yes&lt;/p&gt; : &lt;p&gt;no&lt;/p&gt;}
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>Error Handling</span>
<code class="searchcode language-js">
useEffect(() => {
    fetch('localhost/users').then(res => {
      if(!res.ok){
        throw new Error ('New error')
      }
      return res.json()
    })
    .then(data => {
      setData(data)
    })
    .catch(err => {
      console.log(err)
    })
}, [])
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>React Router</span>
<code class="searchcode language-js">
import { BrowserRouter as Router, Route, 
Switch, NavLink, Link } from 'react-router-dom'
//Switch shows only one component at once.
//NavLink sets active class on click
//Link doesn't refresh the page
&lt;Router&gt;
  &lt;div className="navbar"&gt;
    &lt;Switch&gt;
      &lt;Route path="/"&gt; &lt;Home /&gt; &lt;/Route&gt;
      &lt;Route path="/about"&gt; &lt;About /&gt; &lt;/Route&gt;
      &lt;Route path="/*"&gt; &lt;Notfound /&gt; &lt;/Route&gt;
    &lt;/Switch&gt;
  &lt;/div&gt;
&lt;/Router&gt;
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>React Error Boundary</span>
<code class="searchcode language-js">
The ErrorBoundary component is the main component 
available in react-error-boundary. 
It allows us to implement the
typical React error boundary with less code.

function App(){
return (
&lt;ErrorBoundary FallbackComponent={OurFallbackComponent}&gt;
  &lt;ComponentThatMightThrowAnError /&gt;
&lt;/ErrorBoundary&gt;
);
}
const OurFallbackComponent = 
({ error, componentStack, resetErrorBoundary }) => {
return (
&lt;div&gt;
  &lt;h1&gt;An error occurred: {error.message}&lt;/h1&gt;
  &lt;button onClick={resetErrorBoundary}&gt;Try again&lt;/button&gt;
&lt;/div&gt;
);
};
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>Otehrs</span>
<code class="searchcode language-js">
controlled and uncontrolled components -
different approaches to handling input form elements in react.
Controlled component - In a controlled component, 
the value of the input element is controlled by React.
Uncontrolled component - In an uncontrolled component,
the value of the input element is handled by the DOM itself.

Prevent re-renders in React?
Re-rendering of a component and it’s child components 
occur when props or state of the component has been changed.

prevent the re-rendering of child component, 
we use the shouldComponentUpdate( )
shouldComponentUpdate() {
  console.log("Does not get rendered");
  return false;
}

</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>React styles component</span>
<code class="searchcode language-js">
Inline Styling
can directly style an element using inline style attributes.
&lt;h3 style={{ color: "Yellow" }}&gt;This is a heading&lt;/h3&gt;

Using JavaScript object
headingStyles = {
color: "blue",
fontSize: "48px"
};
&lt;h3 style={this.headingStyles}&gt;This is a heading&lt;/h3&gt;

CSS Stylesheet
import './RandomComponent.css';
&lt;h3 className="heading"&gt;This is a heading&lt;/h3&gt;

CSS Modules
.paragraph{
color:"red";
border:1px solid black;
}
import styles from './styles.module.css';
&lt;p className={styles.paragraph}&gt;This is a paragraph&lt;/p&gt;
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>Optimize React app performance</span>
<code class="searchcode language-js">
Using React.PureComponent -
It is a base component class that checks state and props 
of a component to know whether the component should be updated.

Lazy Loading -
It is a technique used to reduce the load time of a React app. 
Lazy loading helps reduce the risk of web app
performances to minimal.
</code>
</pre>
  </div>
  <!------------------------------------------------------->
  <div class="js codeitem">
    <pre>
<span>Keys in React</span>
<code class="searchcode language-js">
const ids = [1,2,3,4,5];
const listElements = ids.map((id)=>{
return(
&lt;li key={id.toString()}&gt;
  {id}
&lt;/li&gt;
)
})
</code>
</pre>
  </div>
</div>
